<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from target/generated-site/xdoc/convert-config-to-xml-mojo.xml at 2021-04-30

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>Revapi Maven Plugin &#x2013; revapi:convert-config-to-xml</title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
<a href="./" id="bannerLeft">Maven Plugin
</a>      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Last Published: 2021-04-30</span>
          &#xA0;| <span id="projectVersion">Version: 0.14.2</span>
      </div>
      <div class="xright">      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
      <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">

  
    <section>
<h2><a name="revapi:convert-config-to-xml"></a>revapi:convert-config-to-xml</h2>
      
<p><b>Full name</b>:</p>
      
<p>org.revapi:revapi-maven-plugin:0.14.2:convert-config-to-xml</p>
      
<p><b>Description</b>:</p>
      
<div>This is a helper goal to convert the old JSON Revapi configuration
inside the POM files into the new XML based format. You usually
need to run this goal just once in each module. 

<p>Note that this does not touch the external configuration files.
The old and new style configuration still works together well,
though.</p>

<p>Note that this goal <b>changes the contents of pom.xml</b> of
the built modules. You are advised to check the modifications for
correctness and to update the formatting of the changed lines to
your liking.</p></div>
      
<p><b>Attributes</b>:</p>
      
<ul>
        
<li>Requires a Maven project to be executed.</li>
        
<li>Executes by direct invocation only.</li>
        
<li>Since version: <code>0.9.0</code>.</li>
        
<li>Binds by default to the <a class="externalLink" href="http://maven.apache.org/ref/current/maven-core/lifecycles.html">lifecycle phase</a>: <code>validate</code>.</li>
      </ul>
      <section>
<h3><a name="Optional_Parameters"></a>Optional Parameters</h3>
        
<table class="bodyTable" border="0">
          
<tr class="a">
            
<th>Name</th>
            
<th>Type</th>
            
<th>Since</th>
            
<th>Description</th>
          </tr>
          
<tr class="b">
            
<td><code><a href="#alwaysCheckForReleaseVersion">&lt;alwaysCheckForReleaseVersion&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>If true (the default) revapi will always download the information
about the latest version from the remote repositories (instead of
using locally cached info). This will respect the offline settings.<br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.alwaysCheckForReleaseVersion</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#analysisConfiguration">&lt;analysisConfiguration&gt;</a></code></td>
            
<td><code>PlexusConfiguration</code></td>
            
<td><code>0.9.0</code></td>
            
<td>The JSON or XML configuration of various analysis options. The
available options depend on what analyzers are present on the
plugin classpath through the
<code>&amp;lt;dependencies&amp;gt;</code>. Consult <a href="examples/configuration.html">configuration documentation</a>
for more details. 

<p>These settings take precedence over the configuration loaded
from <code>analysisConfigurationFiles</code>.</p><br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#analysisConfigurationFiles">&lt;analysisConfigurationFiles&gt;</a></code></td>
            
<td><code>Object[]</code></td>
            
<td><code>0.9.0</code></td>
            
<td>The list of files containing the configuration of various analysis
options. The available options depend on what analyzers are present
on the plugins classpath through the
<code>&amp;lt;dependencies&amp;gt;</code>. 

<p>The <code>analysisConfiguration</code> can override the settings
present in the files.</p>

<p>The list is either a list of strings or has the following
form:</p>

<div>
<pre>
<code>
  &lt;analysisConfigurationFiles&gt;
       &lt;configurationFile&gt;
           &lt;path&gt;path/to/the/file/relative/to/project/base/dir&lt;/path&gt;
           &lt;resource&gt;path/to/the/file/in/one/of/the/dependencies&lt;/resource&gt;
           &lt;roots&gt;
               &lt;root&gt;configuration/root1&lt;/root&gt;
               &lt;root&gt;configuration/root2&lt;/root&gt;
               ...
           &lt;/roots&gt;
       &lt;/configurationFile&gt;
       ...
   &lt;/analysisConfigurationFiles&gt;
</code>
</pre></div>

where 

<ul>

<li><code>path</code> is the path on the filesystem,</li>

<li><code>resource</code> is the path to the resource file in one
of the artifacts the plugin depends on</li>

<li><code>roots</code> is optional and specifies the subtrees of
the JSON/XML config that should be used for configuration. If not
specified, the whole file is taken into account.</li>
</ul>
Either <code>path</code> or <code>resource</code> has to be
specified but not both. The <code>configuration/root1</code> and
<code>configuration/root2</code> are paths to the roots of the
configuration inside that JSON/XML config file. This might be used
in cases where multiple configurations are stored within a single
file and you want to use a particular one. 

<p>An example of this might be a config file which contains API
changes to be ignored in all past versions of a library. The
classes to be ignored are specified in a configuration that is
specific for each version:</p>

<div>
<pre>
<code>
   {
        &quot;0.1.0&quot; : [
            {
                &quot;extension&quot;: &quot;revapi.ignore&quot;,
                &quot;configuration&quot;: [
                    {
                        &quot;code&quot; : &quot;java.method.addedToInterface&quot;,
                        &quot;new&quot; : &quot;method void com.example.MyInterface::newMethod()&quot;,
                        &quot;justification&quot; : &quot;This interface is not supposed to be implemented by clients.&quot;
                    },
                    ...
                ]
            }
        ],
        &quot;0.2.0&quot; : [
            ...
        ]
    }
</code>
</pre></div><br /><b>User property is</b>: <code>revapi.analysisConfigurationFiles</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#checkDependencies">&lt;checkDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>Whether to include the dependencies in the API checks. This is the
default thing to do because your API might be exposing classes from
the dependencies and thus classes from your dependencies could
become part of your API. 

<p>However, setting this to false might be useful in situations
where you have checked your dependencies in another module and
don't want do that again. In that case, you might want to configure
Revapi to ignore missing classes because it might find the classes
from your dependencies as used in your API and would complain that
it could not find it. See <a class="externalLink" href="http://revapi.org/modules/revapi-java/extensions/java.html">the
docs</a>.</p><br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.checkDependencies</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#convertAnalysisConfigurationFiles">&lt;convertAnalysisConfigurationFiles&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>Whether to convert the contents of the external configuration files
specified by the <code>analysisConfigurationFiles</code> from JSON
to XML. 

<p>Note that external configuration files with custom root elements
are not supported, because it would not be clear how to convert the
rest of the file into XML.</p>

<p>Also note that the original file will be left intact by the
conversion and a new file with the same name and &quot;.xml&quot; extension
will be created in the same directory and the pom.xml will be
updated to point to this new file. You should delete the old file
after making sure the conversion went fine.</p><br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.convertAnalysisConfigurationFiles</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#convertPomXml">&lt;convertPomXml&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>Whether to convert the <code>analysisConfiguration</code> elements
in pom.xml from JSON to XML or not.<br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.convertPomXml</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#disallowedExtensions">&lt;disallowedExtensions&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.9.0</code></td>
            
<td><b>Deprecated.</b> since 0.11.0, use the <code>pipelineConfiguration</code> instead<br /><b>User property is</b>: <code>revapi.disallowedExtensions</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#expandProperties">&lt;expandProperties&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.11.6</code></td>
            
<td>If set to true, the Maven properties will be expanded in the
configuration before it is supplied to Revapi. I.e. any
<code>${var</code>} appearing in the configuration <b>values</b>
will be replaced with the value of the <code>var</code> property as
known to Maven. If the property is not defined, the expansion
doesn't take place.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.expandProperties</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#failBuildOnProblemsFound">&lt;failBuildOnProblemsFound&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>If true (the default), the maven plugin will fail the build when it
finds API problems (e.g. problems with with the criticality at
least equal to <code>failCriticality</code>).<br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.failBuildOnProblemsFound</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#failCriticality">&lt;failCriticality&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.12.0</code></td>
            
<td>The minimum criticality of the found differences at which to fail
the build. This has to be one of the criticalities configured in
the pipeline configuration (if the pipeline configuration doesn't
define any, the following are the default ones:
<code>allowed</code>, <code>documented</code>,
<code>highlight</code>, <code>error</code>). If not defined, the
value is derived from <code>failSeverity</code> using the
severity-to-criticality mapping (which is again configured in the
pipeline configuration. If not defined in the pipeline
configuration explicitly, the default mapping is the following:
<code>EQUIVALENT</code> = <code>allowed</code>,
<code>NON_BREAKING</code> = <code>documented</code>,
<code>POTENTIALLY_BREAKING</code> = <code>error</code>,
<code>BREAKING</code> = error.<br /><b>User property is</b>: <code>revapi.maximumCriticality</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#failOnMissingConfigurationFiles">&lt;failOnMissingConfigurationFiles&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>Set to false if you want to tolerate files referenced in the
<code>analysisConfigurationFiles</code> missing on the filesystem
and therefore not contributing to the analysis configuration. 

<p>The default is <code>true</code>, which means that a missing
analysis configuration file will fail the build.</p><br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.failOnMissingConfigurationFiles</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#failOnUnresolvedArtifacts">&lt;failOnUnresolvedArtifacts&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>If true, the build will fail if one of the old or new artifacts
fails to be resolved. Defaults to false.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.failOnUnresolvedArtifacts</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#failOnUnresolvedDependencies">&lt;failOnUnresolvedDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>If true, the build will fail if some of the dependencies of the old
or new artifacts fail to be resolved. Defaults to false.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.failOnUnresolvedDependencies</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#failSeverity">&lt;failSeverity&gt;</a></code></td>
            
<td><code>FailSeverity</code></td>
            
<td><code>0.9.0</code></td>
            
<td><b>Deprecated.</b> use the new <code>failCriticality</code><br /><b>Default value is</b>: <code>potentiallyBreaking</code>.<br /><b>User property is</b>: <code>revapi.failSeverity</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#newArtifacts">&lt;newArtifacts&gt;</a></code></td>
            
<td><code>String[]</code></td>
            
<td><code>0.9.0</code></td>
            
<td>The coordinates of the new artifacts. These are the full GAVs of
the artifacts, which means that you can compare different artifacts
than the one being built. If you merely want to specify the
artifact being built, use <code>newVersion</code> property instead.<br /><b>User property is</b>: <code>revapi.newArtifacts</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#newPromotedDependencies">&lt;newPromotedDependencies&gt;</a></code></td>
            
<td><code>PromotedDependency[]</code></td>
            
<td><code>0.13.6</code></td>
            
<td>A list of dependencies of the new artifact(s) that should be
considered part of the new API.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#newVersion">&lt;newVersion&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.9.0</code></td>
            
<td>The new version of the artifact. Defaults to &quot;${project.version}&quot;.<br /><b>Default value is</b>: <code>${project.version}</code>.<br /><b>User property is</b>: <code>revapi.newVersion</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#oldArtifacts">&lt;oldArtifacts&gt;</a></code></td>
            
<td><code>String[]</code></td>
            
<td><code>0.9.0</code></td>
            
<td>The coordinates of the old artifacts. Defaults to single artifact
with the latest released version of the current project. 

<p>If the this property is null, the <code>oldVersion</code>
property is checked for a value of the old version of the artifact
being built.</p><br /><b>User property is</b>: <code>revapi.oldArtifacts</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#oldPromotedDependencies">&lt;oldPromotedDependencies&gt;</a></code></td>
            
<td><code>PromotedDependency[]</code></td>
            
<td><code>0.13.6</code></td>
            
<td>A list of dependencies of the old artifact(s) that should be
considered part of the old API.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#oldVersion">&lt;oldVersion&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.9.0</code></td>
            
<td>If you don't want to compare a different artifact than the one
being built, specifying the just the old version is simpler way of
specifying the old artifact. 

<p>The default value is &quot;RELEASE&quot; meaning that the old version is
the last released version of the artifact being built (either
remote or found locally (to account for artifacts installed into
the local repo that are not available in some public remote
repository)). The version of the compared artifact will be strictly
older than the version of the new artifact.</p>

<p>If you specify &quot;LATEST&quot;, the old version will be resolved to the
newest version available remotely, including snapshots (if found in
one of the repositories active in the build). The version of the
compared artifact will be either older or equal to the version of
the new artifact in this case to account for comparing a locally
built snapshot against the latest published snapshot.</p><br /><b>Default value is</b>: <code>RELEASE</code>.<br /><b>User property is</b>: <code>revapi.oldVersion</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#pipelineConfiguration">&lt;pipelineConfiguration&gt;</a></code></td>
            
<td><code>PlexusConfiguration</code></td>
            
<td><code>0.11.0</code></td>
            
<td>The JSON or XML configuration of the extensions pipeline. This
enables the users easily specify which extensions should be
included/excluded in the Revapi analysis pipeline and also to
define transformation blocks - a way of grouping transforms
together to enable more fine grained control over how differences
are transformed.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#promotedDependencies">&lt;promotedDependencies&gt;</a></code></td>
            
<td><code>PromotedDependency[]</code></td>
            
<td><code>0.13.6</code></td>
            
<td>A list of dependencies of both the old and new artifact(s) that
should be considered part of the old/new API. This is a convenience
property if you just need to specify a set of dependencies to
promote into the API and that set can be specified in a way common
to both old and new APIs. If you need to specify different sets for
the old and new, use <code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> respectively. If
<code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> are specified, they override
whatever is specified using this property. 

<p>The individual properties of the dependency (e.g.
<code>groupId</code>, <code>artifactId</code>,
<code>version</code>, <code>type</code> or <code>classifier</code>)
are matched exactly. If you enclose the value in forward slashes,
they are matched as regular expressions instead.</p>

<p>E.g. <code>&lt;groupId&gt;com.acme&lt;/groupId&gt;</code> will
only match dependencies with that exact <code>groupId</code>, while
<code>&lt;groupId&gt;/com\.acme(\..*)?/&lt;/groupId&gt;</code> will
match &quot;com.acme&quot; <code>groupId</code> or any &quot;sub-groupId&quot; thereof
(e.g. &quot;com.acme.utils&quot;, etc.) using a regular expression.</p><br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#resolveProvidedDependencies">&lt;resolveProvidedDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>When establishing the API classes, Revapi by default also looks
through the <code>provided</code> dependencies. The reason for this
is that even though such dependencies do not appear in the
transitive dependency set established by maven, they need to be
present both on the compilation and runtime classpath of the
module. Therefore, the classes in the module are free to expose
classes from a provided dependency as API elements. 

<p>In rare circumstances this is not a desired behavior though. It
is undesired if for example the classes from the provided
dependency are used only for establishing desired build order or
when they are used in some non-standard scenarios during the build
and actually not needed at runtime.</p>

<p>Note that this property only influences the resolution of
provided dependencies of the main artifacts, not the transitively
reachable provided dependencies. For those, use the
<code>resolveTransitiveProvidedDependencies</code> parameter.</p><br /><b>Default value is</b>: <code>true</code>.<br /><b>User property is</b>: <code>revapi.resolveProvidedDependencies</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#resolveTransitiveProvidedDependencies">&lt;resolveTransitiveProvidedDependencies&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>In addition to <code>resolveProvidedDependencies</code> this
property further controls how provided dependencies are resolved.
Using this property you can control how the indirect, transitively
reachable, provided dependencies are treated. The default is to not
consider them, which is almost always the right thing to do. It
might be necessary to set this property to <code>true</code> in the
rare circumstances where the API of the main artifacts includes
types from such transitively included provided dependencies. Such
occurrence will manifest itself by Revapi considering such types as
missing (which is by default reported as a potentially breaking
change). When you then resolve the transitive provided dependencies
(by setting this parameter to true), Revapi will be able to find
such types and do a proper analysis of them.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.resolveTransitiveProvidedDependencies</code>.<br /></td>
          </tr>
          
<tr class="b">
            
<td><code><a href="#skip">&lt;skip&gt;</a></code></td>
            
<td><code>boolean</code></td>
            
<td><code>0.9.0</code></td>
            
<td>Whether to skip the mojo execution.<br /><b>Default value is</b>: <code>false</code>.<br /><b>User property is</b>: <code>revapi.skip</code>.<br /></td>
          </tr>
          
<tr class="a">
            
<td><code><a href="#versionFormat">&lt;versionFormat&gt;</a></code></td>
            
<td><code>String</code></td>
            
<td><code>0.9.0</code></td>
            
<td>If set, this property demands a format of the version string when
the <code>oldVersion</code> or <code>newVersion</code> parameters
are set to <code>RELEASE</code> or <code>LATEST</code> special
version strings. 

<p>Because Maven will report the newest non-snapshot version as the
latest release, we might end up comparing a <code>.Beta</code> or
other pre-release versions with the new version. This might not be
what you want and setting the versionFormat will make sure that a
newest version conforming to the version format is used instead of
the one resolved by Maven by default.</p>

<p>This parameter is a regular expression pattern that the version
string needs to match in order to be considered a
<code>RELEASE</code>.</p><br /><b>User property is</b>: <code>revapi.versionFormat</code>.<br /></td>
          </tr>
        </table>
      </section>
      <section>
<h3><a name="Parameter_Details"></a>Parameter Details</h3>
        <section>
<h4><a name="a.3CalwaysCheckForReleaseVersion.3E"></a><b><a name="alwaysCheckForReleaseVersion">&lt;alwaysCheckForReleaseVersion&gt;</a></b></h4>
        
<div>If true (the default) revapi will always download the information
about the latest version from the remote repositories (instead of
using locally cached info). This will respect the offline settings.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.alwaysCheckForReleaseVersion</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CanalysisConfiguration.3E"></a><b><a name="analysisConfiguration">&lt;analysisConfiguration&gt;</a></b></h4>
        
<div>The JSON or XML configuration of various analysis options. The
available options depend on what analyzers are present on the
plugin classpath through the
<code>&amp;lt;dependencies&amp;gt;</code>. Consult <a href="examples/configuration.html">configuration documentation</a>
for more details. 

<p>These settings take precedence over the configuration loaded
from <code>analysisConfigurationFiles</code>.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>org.codehaus.plexus.configuration.PlexusConfiguration</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CanalysisConfigurationFiles.3E"></a><b><a name="analysisConfigurationFiles">&lt;analysisConfigurationFiles&gt;</a></b></h4>
        
<div>The list of files containing the configuration of various analysis
options. The available options depend on what analyzers are present
on the plugins classpath through the
<code>&amp;lt;dependencies&amp;gt;</code>. 

<p>The <code>analysisConfiguration</code> can override the settings
present in the files.</p>

<p>The list is either a list of strings or has the following
form:</p>

<div>
<pre>
<code>
  &lt;analysisConfigurationFiles&gt;
       &lt;configurationFile&gt;
           &lt;path&gt;path/to/the/file/relative/to/project/base/dir&lt;/path&gt;
           &lt;resource&gt;path/to/the/file/in/one/of/the/dependencies&lt;/resource&gt;
           &lt;roots&gt;
               &lt;root&gt;configuration/root1&lt;/root&gt;
               &lt;root&gt;configuration/root2&lt;/root&gt;
               ...
           &lt;/roots&gt;
       &lt;/configurationFile&gt;
       ...
   &lt;/analysisConfigurationFiles&gt;
</code>
</pre></div>

where 

<ul>

<li><code>path</code> is the path on the filesystem,</li>

<li><code>resource</code> is the path to the resource file in one
of the artifacts the plugin depends on</li>

<li><code>roots</code> is optional and specifies the subtrees of
the JSON/XML config that should be used for configuration. If not
specified, the whole file is taken into account.</li>
</ul>
Either <code>path</code> or <code>resource</code> has to be
specified but not both. The <code>configuration/root1</code> and
<code>configuration/root2</code> are paths to the roots of the
configuration inside that JSON/XML config file. This might be used
in cases where multiple configurations are stored within a single
file and you want to use a particular one. 

<p>An example of this might be a config file which contains API
changes to be ignored in all past versions of a library. The
classes to be ignored are specified in a configuration that is
specific for each version:</p>

<div>
<pre>
<code>
   {
        &quot;0.1.0&quot; : [
            {
                &quot;extension&quot;: &quot;revapi.ignore&quot;,
                &quot;configuration&quot;: [
                    {
                        &quot;code&quot; : &quot;java.method.addedToInterface&quot;,
                        &quot;new&quot; : &quot;method void com.example.MyInterface::newMethod()&quot;,
                        &quot;justification&quot; : &quot;This interface is not supposed to be implemented by clients.&quot;
                    },
                    ...
                ]
            }
        ],
        &quot;0.2.0&quot; : [
            ...
        ]
    }
</code>
</pre></div></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.Object[]</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.analysisConfigurationFiles</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CcheckDependencies.3E"></a><b><a name="checkDependencies">&lt;checkDependencies&gt;</a></b></h4>
        
<div>Whether to include the dependencies in the API checks. This is the
default thing to do because your API might be exposing classes from
the dependencies and thus classes from your dependencies could
become part of your API. 

<p>However, setting this to false might be useful in situations
where you have checked your dependencies in another module and
don't want do that again. In that case, you might want to configure
Revapi to ignore missing classes because it might find the classes
from your dependencies as used in your API and would complain that
it could not find it. See <a class="externalLink" href="http://revapi.org/modules/revapi-java/extensions/java.html">the
docs</a>.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.checkDependencies</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CconvertAnalysisConfigurationFiles.3E"></a><b><a name="convertAnalysisConfigurationFiles">&lt;convertAnalysisConfigurationFiles&gt;</a></b></h4>
        
<div>Whether to convert the contents of the external configuration files
specified by the <code>analysisConfigurationFiles</code> from JSON
to XML. 

<p>Note that external configuration files with custom root elements
are not supported, because it would not be clear how to convert the
rest of the file into XML.</p>

<p>Also note that the original file will be left intact by the
conversion and a new file with the same name and &quot;.xml&quot; extension
will be created in the same directory and the pom.xml will be
updated to point to this new file. You should delete the old file
after making sure the conversion went fine.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.convertAnalysisConfigurationFiles</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CconvertPomXml.3E"></a><b><a name="convertPomXml">&lt;convertPomXml&gt;</a></b></h4>
        
<div>Whether to convert the <code>analysisConfiguration</code> elements
in pom.xml from JSON to XML or not.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.convertPomXml</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CdisallowedExtensions.3E"></a><b><a name="disallowedExtensions">&lt;disallowedExtensions&gt;</a></b></h4>
        
<div><b>Deprecated.</b> since 0.11.0, use the <code>pipelineConfiguration</code> instead</div>
        
<div>A comma-separated list of extensions (fully-qualified class names
thereof) that are not taken into account during API analysis. By
default, all extensions that are found on the classpath are used. 

<p>You can modify this set if you use another extensions that
change the found differences in a way that the determined new
version would not correspond to what it should be.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.disallowedExtensions</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CexpandProperties.3E"></a><b><a name="expandProperties">&lt;expandProperties&gt;</a></b></h4>
        
<div>If set to true, the Maven properties will be expanded in the
configuration before it is supplied to Revapi. I.e. any
<code>${var</code>} appearing in the configuration <b>values</b>
will be replaced with the value of the <code>var</code> property as
known to Maven. If the property is not defined, the expansion
doesn't take place.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.11.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.expandProperties</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailBuildOnProblemsFound.3E"></a><b><a name="failBuildOnProblemsFound">&lt;failBuildOnProblemsFound&gt;</a></b></h4>
        
<div>If true (the default), the maven plugin will fail the build when it
finds API problems (e.g. problems with with the criticality at
least equal to <code>failCriticality</code>).</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failBuildOnProblemsFound</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailCriticality.3E"></a><b><a name="failCriticality">&lt;failCriticality&gt;</a></b></h4>
        
<div>The minimum criticality of the found differences at which to fail
the build. This has to be one of the criticalities configured in
the pipeline configuration (if the pipeline configuration doesn't
define any, the following are the default ones:
<code>allowed</code>, <code>documented</code>,
<code>highlight</code>, <code>error</code>). If not defined, the
value is derived from <code>failSeverity</code> using the
severity-to-criticality mapping (which is again configured in the
pipeline configuration. If not defined in the pipeline
configuration explicitly, the default mapping is the following:
<code>EQUIVALENT</code> = <code>allowed</code>,
<code>NON_BREAKING</code> = <code>documented</code>,
<code>POTENTIALLY_BREAKING</code> = <code>error</code>,
<code>BREAKING</code> = error.</div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.12.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.maximumCriticality</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailOnMissingConfigurationFiles.3E"></a><b><a name="failOnMissingConfigurationFiles">&lt;failOnMissingConfigurationFiles&gt;</a></b></h4>
        
<div>Set to false if you want to tolerate files referenced in the
<code>analysisConfigurationFiles</code> missing on the filesystem
and therefore not contributing to the analysis configuration. 

<p>The default is <code>true</code>, which means that a missing
analysis configuration file will fail the build.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failOnMissingConfigurationFiles</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailOnUnresolvedArtifacts.3E"></a><b><a name="failOnUnresolvedArtifacts">&lt;failOnUnresolvedArtifacts&gt;</a></b></h4>
        
<div>If true, the build will fail if one of the old or new artifacts
fails to be resolved. Defaults to false.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failOnUnresolvedArtifacts</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailOnUnresolvedDependencies.3E"></a><b><a name="failOnUnresolvedDependencies">&lt;failOnUnresolvedDependencies&gt;</a></b></h4>
        
<div>If true, the build will fail if some of the dependencies of the old
or new artifacts fail to be resolved. Defaults to false.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failOnUnresolvedDependencies</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CfailSeverity.3E"></a><b><a name="failSeverity">&lt;failSeverity&gt;</a></b></h4>
        
<div><b>Deprecated.</b> use the new <code>failCriticality</code></div>
        
<div>The severity of found problems at which to break the build.
Defaults to potentiallyBreaking. Possible values: equivalent,
nonBreaking, potentiallyBreaking, breaking.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.FailSeverity</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.failSeverity</code></li>
          
<li><b>Default</b>: <code>potentiallyBreaking</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CnewArtifacts.3E"></a><b><a name="newArtifacts">&lt;newArtifacts&gt;</a></b></h4>
        
<div>The coordinates of the new artifacts. These are the full GAVs of
the artifacts, which means that you can compare different artifacts
than the one being built. If you merely want to specify the
artifact being built, use <code>newVersion</code> property instead.</div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String[]</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.newArtifacts</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CnewPromotedDependencies.3E"></a><b><a name="newPromotedDependencies">&lt;newPromotedDependencies&gt;</a></b></h4>
        
<div>A list of dependencies of the new artifact(s) that should be
considered part of the new API.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.PromotedDependency[]</code></li>
          
<li><b>Since</b>: <code>0.13.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CnewVersion.3E"></a><b><a name="newVersion">&lt;newVersion&gt;</a></b></h4>
        
<div>The new version of the artifact. Defaults to &quot;${project.version}&quot;.</div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.newVersion</code></li>
          
<li><b>Default</b>: <code>${project.version}</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3ColdArtifacts.3E"></a><b><a name="oldArtifacts">&lt;oldArtifacts&gt;</a></b></h4>
        
<div>The coordinates of the old artifacts. Defaults to single artifact
with the latest released version of the current project. 

<p>If the this property is null, the <code>oldVersion</code>
property is checked for a value of the old version of the artifact
being built.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String[]</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.oldArtifacts</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3ColdPromotedDependencies.3E"></a><b><a name="oldPromotedDependencies">&lt;oldPromotedDependencies&gt;</a></b></h4>
        
<div>A list of dependencies of the old artifact(s) that should be
considered part of the old API.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.PromotedDependency[]</code></li>
          
<li><b>Since</b>: <code>0.13.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3ColdVersion.3E"></a><b><a name="oldVersion">&lt;oldVersion&gt;</a></b></h4>
        
<div>If you don't want to compare a different artifact than the one
being built, specifying the just the old version is simpler way of
specifying the old artifact. 

<p>The default value is &quot;RELEASE&quot; meaning that the old version is
the last released version of the artifact being built (either
remote or found locally (to account for artifacts installed into
the local repo that are not available in some public remote
repository)). The version of the compared artifact will be strictly
older than the version of the new artifact.</p>

<p>If you specify &quot;LATEST&quot;, the old version will be resolved to the
newest version available remotely, including snapshots (if found in
one of the repositories active in the build). The version of the
compared artifact will be either older or equal to the version of
the new artifact in this case to account for comparing a locally
built snapshot against the latest published snapshot.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.oldVersion</code></li>
          
<li><b>Default</b>: <code>RELEASE</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CpipelineConfiguration.3E"></a><b><a name="pipelineConfiguration">&lt;pipelineConfiguration&gt;</a></b></h4>
        
<div>The JSON or XML configuration of the extensions pipeline. This
enables the users easily specify which extensions should be
included/excluded in the Revapi analysis pipeline and also to
define transformation blocks - a way of grouping transforms
together to enable more fine grained control over how differences
are transformed.</div>
        
<ul>
          
<li><b>Type</b>: <code>org.codehaus.plexus.configuration.PlexusConfiguration</code></li>
          
<li><b>Since</b>: <code>0.11.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CpromotedDependencies.3E"></a><b><a name="promotedDependencies">&lt;promotedDependencies&gt;</a></b></h4>
        
<div>A list of dependencies of both the old and new artifact(s) that
should be considered part of the old/new API. This is a convenience
property if you just need to specify a set of dependencies to
promote into the API and that set can be specified in a way common
to both old and new APIs. If you need to specify different sets for
the old and new, use <code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> respectively. If
<code>oldPromotedDependencies</code> or
<code>newPromotedDependencies</code> are specified, they override
whatever is specified using this property. 

<p>The individual properties of the dependency (e.g.
<code>groupId</code>, <code>artifactId</code>,
<code>version</code>, <code>type</code> or <code>classifier</code>)
are matched exactly. If you enclose the value in forward slashes,
they are matched as regular expressions instead.</p>

<p>E.g. <code>&lt;groupId&gt;com.acme&lt;/groupId&gt;</code> will
only match dependencies with that exact <code>groupId</code>, while
<code>&lt;groupId&gt;/com\.acme(\..*)?/&lt;/groupId&gt;</code> will
match &quot;com.acme&quot; <code>groupId</code> or any &quot;sub-groupId&quot; thereof
(e.g. &quot;com.acme.utils&quot;, etc.) using a regular expression.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>org.revapi.maven.PromotedDependency[]</code></li>
          
<li><b>Since</b>: <code>0.13.6</code></li>
          
<li><b>Required</b>: <code>No</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CresolveProvidedDependencies.3E"></a><b><a name="resolveProvidedDependencies">&lt;resolveProvidedDependencies&gt;</a></b></h4>
        
<div>When establishing the API classes, Revapi by default also looks
through the <code>provided</code> dependencies. The reason for this
is that even though such dependencies do not appear in the
transitive dependency set established by maven, they need to be
present both on the compilation and runtime classpath of the
module. Therefore, the classes in the module are free to expose
classes from a provided dependency as API elements. 

<p>In rare circumstances this is not a desired behavior though. It
is undesired if for example the classes from the provided
dependency are used only for establishing desired build order or
when they are used in some non-standard scenarios during the build
and actually not needed at runtime.</p>

<p>Note that this property only influences the resolution of
provided dependencies of the main artifacts, not the transitively
reachable provided dependencies. For those, use the
<code>resolveTransitiveProvidedDependencies</code> parameter.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.resolveProvidedDependencies</code></li>
          
<li><b>Default</b>: <code>true</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CresolveTransitiveProvidedDependencies.3E"></a><b><a name="resolveTransitiveProvidedDependencies">&lt;resolveTransitiveProvidedDependencies&gt;</a></b></h4>
        
<div>In addition to <code>resolveProvidedDependencies</code> this
property further controls how provided dependencies are resolved.
Using this property you can control how the indirect, transitively
reachable, provided dependencies are treated. The default is to not
consider them, which is almost always the right thing to do. It
might be necessary to set this property to <code>true</code> in the
rare circumstances where the API of the main artifacts includes
types from such transitively included provided dependencies. Such
occurrence will manifest itself by Revapi considering such types as
missing (which is by default reported as a potentially breaking
change). When you then resolve the transitive provided dependencies
(by setting this parameter to true), Revapi will be able to find
such types and do a proper analysis of them.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.resolveTransitiveProvidedDependencies</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3Cskip.3E"></a><b><a name="skip">&lt;skip&gt;</a></b></h4>
        
<div>Whether to skip the mojo execution.</div>
        
<ul>
          
<li><b>Type</b>: <code>boolean</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.skip</code></li>
          
<li><b>Default</b>: <code>false</code></li>
        </ul><hr /></section><section>
<h4><a name="a.3CversionFormat.3E"></a><b><a name="versionFormat">&lt;versionFormat&gt;</a></b></h4>
        
<div>If set, this property demands a format of the version string when
the <code>oldVersion</code> or <code>newVersion</code> parameters
are set to <code>RELEASE</code> or <code>LATEST</code> special
version strings. 

<p>Because Maven will report the newest non-snapshot version as the
latest release, we might end up comparing a <code>.Beta</code> or
other pre-release versions with the new version. This might not be
what you want and setting the versionFormat will make sure that a
newest version conforming to the version format is used instead of
the one resolved by Maven by default.</p>

<p>This parameter is a regular expression pattern that the version
string needs to match in order to be considered a
<code>RELEASE</code>.</p></div>
        
<ul>
          
<li><b>Type</b>: <code>java.lang.String</code></li>
          
<li><b>Since</b>: <code>0.9.0</code></li>
          
<li><b>Required</b>: <code>No</code></li>
          
<li><b>User Property</b>: <code>revapi.versionFormat</code></li>
        </ul>
      </section></section>
    </section>
  

      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2014&#x2013;2021<a href="http://lukas.krejci.pw">Lukas Krejci</a>.
.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
